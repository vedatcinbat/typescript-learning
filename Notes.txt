*** TypeScript Notes ***

########################################################################################################
* SECTION 1 : Introduction *
---------------------------------------
* Topics
---------------------------------------
-> Installation
-> Type Basics
-> Functions
-> Object Types
-> Array Types 
-> Union Types 
-> Tuples/Enums
-> Interfaces
-> TS Compiler
-> DOM Mini Project
-> JS Classes
-> TS Classes 
-> Generics
-> Narrowing
-> Declarations
-> Modules
-> Webpack + TS
-> React + TS

---------------------------------------
* What is TypeScript ?
---------------------------------------
-> Typescript is a programming language developed by Microsoft that extends JavaScript by adding
static types
-> It is designed for large-scale Javascript application development, offering benefits such as improved
maintainability, easier refactoring, and better tooling support through type-checking
-> Key Features: Static Typing | ES6+ Features | Type Inference | Interface and Type Declarations 
-> Advantages of TypeScript : 
--> Type Safety
--> Improved Code Quality
--> Better Tooling
--> Ecosystem Compatibility
--> Scalability
-> Overall, Typescript aims to make JavaScript development more robust and scalable by introducing static typing
and other features without sacrificing compatibility with JS's ecosystem

-> JavaScript is quirky...
-> Typescript is Javascript with types

---------------------------------------
* TypeScript Overview
---------------------------------------
-> Static Checking : Typescript detects erros in our code "without running it"
-> This is called static checking
-> TypeScript does this error checknig on the basis of "kinds of data" in our program
AKA types
-> TypeScript's Type System
--> Helpos us find erros
--> Analyzes our code as we type
--> Only exists in development
-> First use ts then compile js
-> Typescript gives the errors before "runtime"
########################################################################################################


########################################################################################################
* SECTION 2 : Installation & Setup *
---------------------------------------
* Installing Typescript
---------------------------------------
-> First install node
-> Then run "npm install -g typescript" for installing typescript globally

---------------------------------------
* The TypeScript Playground
---------------------------------------
-> You can use for trying codes online : https://www.typescriptlang.org/play/

---------------------------------------
* How We Use Typescript
---------------------------------------
-> Create ".ts" file
-> Make some work
-> Compile that ts code into js with "tsc" command
> tsc <filename>.tsc
-> Then run that .js file with node command
> node <filename>.js
########################################################################################################


########################################################################################################
* SECTION 3 : Type Annotation Basics *
---------------------------------------
* Our First Type Annotation
---------------------------------------
-> Primitive Types 
--> Number | String | Booelan | Null | Undefined | Void | Any | Never | Unknown
-> Object Types
--> Object | Array | Function | Tuple | Enum | Others

-> Where we use that types in our projects
--> "This variable is a string"
--> "This function returns a boolean"
--> "This function accepts two numbers and returns a number"
--> "This object must have a property called "colors", set to an array of strings"

-> Variable Types: Assigning a basic type to a variable is easy - just add ":Type" after
the variable name! (Also called 'Type Annotation')

// Declaring a variable in JS
> const myAwesomeVariable = 'So Awesome!';
// Declaring a variable in TS
> const myAwesomeVariable: string = 'So Awesome!';

-> let myVar: type = value


-> Strings: Strings represent character values like "I love Typescript"
-> We can tell TypeScript that something is a string using the type annotation fo "string" (all lowercase)

> let myString: string = "Words!!!";

(x) myString = 100; // CAN'T reassign to a different type

(ok) myString = "New Words!!!!";


---------------------------------------
* Working With Numbers & Booleans
---------------------------------------
-> Some programming langauges have many number types  - float, int etc.
-> In TypeScript numbers are just numbers
-> Numbers can be typed with a simple Type Annotation of "number" (all lowercase)

> let myNumber: number = 42;
> myNumber = "I'm a string!"; (x)
> myNumber = 60; // CAN reassign to a value of same type

-> Boolean variables represent simple "true" or "false" values
-> Booleans can be typed with a simple type annotation of "boolean"

> const myBoolean: boolean = true;
> myBoolean = 87; (x)
> myBoolean = false; (ok)


---------------------------------------
* Compiling TypeScript
---------------------------------------
-> Go the folder that you want to run "tsc" command in it
-> Then run "tsc <filename>.tsc"
-> Then run "node <filename>.js"

-> At the end of day, we are getting plain js file because browser can only understand plain 
javascript code


---------------------------------------
* Type Inference
---------------------------------------
-> Type Inference refers to the Typescript compiler's ability to infer types from certain
values in your code
-> Typescript can remember a value's type even if you didn't provide a type annotation, and
it will enforce that type moving forword

> let x = 27;
> x = 'twenty-seven';
// ERROR - Type 'string' is not assignable to type 'number'

---------------------------------------
* Any Type
---------------------------------------
-> 'any' is an escape hatch!
-> It turns off type checking for this variable so you can do your thing
-> NOTE: it sort of defats the purpose of TS and types, so use it sparingly!

> const myComplicatedData: any = "I'm going to be complicated!";

> myComplicatedData = 87; // OK
> myComplicatedData = "abc..."; // OK
> myComplicatedData = true; // OK
########################################################################################################


########################################################################################################
* SECTION 4 : Functions *
---------------------------------------
* Function Parameter Types
---------------------------------------
-> In TypeScript, we can specify the type fo function parameters in a function definition
-> This allows Typescript to enforce the types for the values being passed into your Function
-> Typing parameters is just like typing variables

> const encourageStudent = (name: string) => {
    return `Hey, ${name}, you're doing GREAT!`;
}

encourageStudent('you'); (ok)

encourageStudent(85); (x) 

> const doSomething = (person: string, age: number, isFunny: boolean) => {
    return `Hi there, ${person}! You are ${age} years old. Are you funny? ${isFunny}`;
}

//console.log(doSomething("VedatCinbat")) // Error: Expected 3 arguments, but got 1.
//console.log(doSomething("VedatCinbat", 24)); // Error: Expected 3 arguments, but got 2.
//console.log(doSomething("VedatCinbat", 24, true)); // Hi there, VedatCinbat! You are 24 years old. Are you funny? true


---------------------------------------
* Working With Default Parameters
---------------------------------------
-> Add "default value" after type annotations

> function greet(person: string = "stranger") {
    return `Hi there, ${person}!`;
}

---------------------------------------
* Return Type Annotation
---------------------------------------
-> We can specify the type returned by a function
-> Even through TypeScript can often infer this, I prefer the explicit annotations
-> Add the type annotation after the functions parameter list

> const addNums = (x: number, y:number): number => {
    return x + y;
}

addNums(5,5);
// --> 10

function rando(num: number): number | string {
    if(Math.random() < 0.5) {
        return num.toString();
    }

    return num;
}


---------------------------------------
* Anonymous Function Contextual Typing
---------------------------------------
-> Anonymous Function: When TypeScript can infer how an unnamed function is going to be called,
it can automatically infer its parameter's types

> const numbers = [1, 2, 3];

> numbers.forEach(num => {
    return num.toUpperCase(); // Error
    // .toUpperCase() doesn't work for nums!
})

> const colors = ['red', 'green', 'blue'];

// TS can automatically infer the type of the return value from
> colors.map(color => {
    return color.toUpperCase()
})


---------------------------------------
* The Void Type
---------------------------------------
-> Void is a return type for functions that don't return anything
-> It means just that - this function is void of any data
-> Typescript can infer this type fairly well, but sometimes it may want you to 
annotate a function with a void return explicity

> const annoyUser = (num: number): void => {
    for(let i = 0; i < num; i++) {
        alert("HIIIII!!");
    }
}

> function printTwice(msg: string): void {
    console.log(msg);
    console.log(msg);

    // return ""; // Error: Type '""' is not assignable to type 'void'.
}

> printTwice("Hello, World!");


---------------------------------------
* Never Type
---------------------------------------
-> The never type represents values that NEVER occur
-> We might use it to annotate a function that always throws an exception, or a function
that never finishes executing
-> Don't confuse with void - void returns undefined or null, which is technically still a 
type of value
-> With "never", a function doesn't even finish executing 

> const neverStop = (): never => {
    while(true) {
        console.log("I'm still going!!!")
    }
}

> const giveError = (msg: string) => {
    throw new Error(msg)
}
########################################################################################################

########################################################################################################
* SECTION 5 : Object Types *
---------------------------------------
* Objects
---------------------------------------
-> Objects can be typed bu declaring what the object should look like in the annotation
-> Accessing a property that isn't defined or performing operations without keeping types in mid
will throw errors!

> const printName = (name: {first: string, last: string}) => {
    return `Name: ${first} ${last}`;
}

printName({first: 'Vedat', last: 'Cinbat'});

function printName(person: {first: string, last: string}) {
    console.log(`${person.first} ${person.last}`)
}

//printName({first: "John"}); // Error: Argument of type '{ first: string; }' is not assignable to parameter of type '{ first: string; last: string; }'.
printName({first: "John", last: "Doe"});


//let coordinate: {x: number, y: number} = {x: 10, y: 20, z: 30}; // Error: Object literal may only specify known properties, and 'z' does not exist in type '{ x: number; y: number; }'.
let coordinate: {x: number, y: number} = {x: 10, y: 20}; // OK

// {x: number, y: number} is a return type
function randomCoordinate(): {x: number, y: number} {
    return {x: Math.random(), y: Math.random()};
}

---------------------------------------
* Excess Properties
---------------------------------------
//printName({first: "Mick", last: "Jagger", age: 47}) // Error: Object literal may only specify known properties, and 'age' does not exist in type '{ first: string; last: string; }'.

const singer = {first: "Mick", last: "Jagger", age: 47, isAlive: true}

printName(singer) // OK


---------------------------------------
* Type Alias
---------------------------------------
-> Instead of writing out object types in an annotation, we can declare them separaretly in a "type alias",
which is simply the desired shape of the object
-> This allows us to make our code more readable and even reuse the types elsewhere in our code 

type Person = {
    name: string;
    age: number;
}

const sayHappyBirthday = (person: Person) => {
    return `Hey ${person.name}, congrats on turning ${person.age}`;
}

sayHappyBirthday({name: "Jerry", age: 42});
--------------------------------------------------------------------------------
type Point = {
    x: number;
    y: number;
}

let coordinate: Point = { x: 10, y: 20 };

function randomCoordinate() {
    return { x: Math.random(), y: Math.random() };
}

function doublePoint(point: Point): Point {
    return {x: point.x * 2, y: point.y * 2};
}

randomCoordinate();
doublePoint(coordinate); // OK


---------------------------------------
* Nested Objects
---------------------------------------
> const describePerson = (person: {
    name: string;
    age: number;
    parentNames: {
        mom: string;
        dad: string;
    }
}) => {
    return `Person: ${name},
    Age: ${age},
    parents: ${parentNames.mom} ${parentNames.dad}`;
}

describePerson({name: 'Jimmy', age: 10, parents: {mom: 'Kim', dad: 'Steve'}})

type Song = { 
    title: string, 
    artist: string, 
    numStreams: number, 
    credits: { 
        producer: string, 
        writer: string 
    } 
}

function calculatePayout(song: Song): number {
    return song.numStreams * 0.0033;
}

function printSong(song: Song): void {
    console.log(`Title: ${song.title} - Artist: ${song.artist}`);
}

const mySong: Song = {
    title: "Unchained Melody",
    artist: "The Righteous Brothers",
    numStreams: 1236573,
    credits: {
        producer: "Phil Spector",
        writer: "Alex North"
    }
}

const earnings = calculatePayout(mySong); // OK
console.log(earnings);
printSong(mySong); // OK

---------------------------------------
* Optional Properties
---------------------------------------
type Point = {
    x: number,
    y: number,
    z?: number // Optional property
}

const point1: Point = { x: 1, y: 2 }; // OK
const point2: Point = { x: 1, y: 2, z: 3 }; // OK
const point3: Point = { x: 1 }; // Error: Property 'y' is missing

---------------------------------------
* The Readonly Modifier
---------------------------------------
type User = {
    readonly id: number,
    username: string,
    readonly hobbies: string[]
}

const user: User = {
    id: 1,
    username: "johndoe",
    hobbies: ["reading", "swimming"]
}

//user.id = 2; // Error: Cannot assign to 'id' because it is a read-only property
user.username = "janedoe"; // OK
user.hobbies.push("running"); // OK

---------------------------------------
* Intersection Types
---------------------------------------
type Circle = {
    radius: number;
}

type Colorful = {
    color: string;
}

type ColorfulCircle = Circle & Colorful;    

const happyFace: ColorfulCircle = {
    radius: 42,
    color: "yellow"
}

const sadFace: ColorfulCircle = {
    radius: 50,
    color: "blue"
}
########################################################################################################

########################################################################################################
* SECTION 6 : Array Types *
---------------------------------------
* Array Types
---------------------------------------
-> Arrays can be typed using a type annotation followed by empty array brackets, like
number[] for an array of numbers
-> Note: These arrays only allow daya fo that one type inside them.

-> Using brackets
> let names: string[] = ["hello", "world"];
> let ages: number[] = [13, 31, 42, 56];

-> Alternate syntax
> let names: Array<string> = ["hello", "world"];
> let ages: Array<number> = [13, 31, 42, 56];


const activeUsers: string[] = ['John', 'Doe', 'Jane'];
const activeNumbers: number[] = [1, 2, 3];


activeUsers.push('Smith');
//activeUsers.push(4); // Error: Argument of type '4' is not assignable to parameter of type 'string'. 


const ageList: number[] = [25, 30, 35, 40];

ageList[0] = 99;
// ageList[0] = "99"; // Error: Type 'string' is not assignable to type 'number'.


---------------------------------------
* More Array Syntax
---------------------------------------
-> We can create our custom type and we can use that custom type for declaring variable 
that array of that custom type :

type Point = {
    x: number;
    y: number;
}

const coords: Point[] = []
coords.push({ x: 10, y: 20 });
//coords.push({x: 8}) // Error: Property 'y' is missing in type '{ x: number; }' but required in type 'Point'.


---------------------------------------
* Multidimensional Arrays
---------------------------------------
// 3x3 board 
const board: string[][] = [
    ["X", "O", "X"], 
    ["O", "X", "O"], 
    ["X", "O", "X"]
]
########################################################################################################

########################################################################################################
* SECTION 7 : Union Types *
---------------------------------------
* Union Types
---------------------------------------
-> Union types allow us to give a value a few different possible types
-> If the eventual value's type is included, TS will be happy
-> We can create a union type by using the single "|" to separate the types we want to include
-> It's like saying, "This thing is allowed to be this, this, or this"
-> TypeScript will enforce it from there 

> const guessAge = (age: number | string) => {
    return "Your age is : " + age;
}

// CAN pass a number or a string
guessAge(30); (ok)
guessAge("28"); (ok)

// CANT pass something else
guessAge({age: 32})


type Point = {
    x: number;
    y: number;
}

type Loc = {
    lat: number;
    long: number;
}

let coordinates: Point | Loc = {x: 1 , y: 34};

coordinates = {lat: 34, long: 56}; // Its valid because coordinates is a union type of Point and Loc


---------------------------------------
* Type Narrowing w/ Union Types
---------------------------------------
-> Narrowing the Type is simply doing a type check before working with a value
-> If you value is a string you may want to use it differently than if you got a number
-> Since unions allow multiple types for a value, it's good to check what cam through before 
working with it

const isTeenager = (age: number | string) => {
    if(typeof age === 'string') {
        console.log(age.charAt(0) === 1);
    }

    if(typeof age === 'number') {
        console.log(age > 12 && age < 20);
    }
}

isTeenager('20'); // false
isTeenager(13); // true

function calculateTax(price: number | string, tax: number) {
    //return price * tax; // Error: Operator '*' cannot be applied to types 'string | number' and 'number'.
    //price.replace("$", ""); // Error: Property 'replace' does not exist on type 'string | number'.

    if(typeof price === 'string') {
        price = parseFloat(price.replace("$", ""));
        // price = .... // Now price is a number
    }

    return price * tax;
}


---------------------------------------
* Union Types and Arrays
---------------------------------------
const stuff: (number | string)[] = [1,2,3,4, "hello", "world"];
const coords: (Point | Loc)[] = [{x: 1, y: 2}, {lat: 34, long: 56}];

const nums: number[] = [1,2,3,4];
// const stuff: any[] = [1,2,3,4, "hello", true, [1,2,3,4], {name: "John"}];
// const stuff: number[] | string[] = [1,2,3] or ["hello", "world"];
// number[] | string[] means that stuff can be either an array of numbers or an array of strings


---------------------------------------
* Literal Types
---------------------------------------
-> Literal types are not just types - but the values themselves too!
-> On it's own, that's not super helpful
-> But combine it with something like unions and you can have very fine-tuned type options
for TypeScript to enforce

> const giveAnswer = (answer: "yes" | "no" | "maybe") => {
    return `The answer is ${answer}.`;
}

giveAnswer("no") // The answer is "no" (ok)
giveAnswer("oh bot I'm not sure"); // CANT PROVIDE ANYTHING ELSE

let zero: 0 = 0
//zero = 2; // Error: Type '2' is not assignable to type '0'

let hi: "hi" = "hi";
//hi = "hello"; // Error: Type '"hello"' is not assignable to type '"hi"'

let answer: "yes" | "no" | "maybe" = "yes";
answer = "no";
answer = "maybe";
//answer = "ok"; // Error: Type '"ok"' is not assignable to type '"yes" | "no" | "maybe"'

let mood: "happy" | "sad" | "angry" | "meh" = "happy";
mood = "sad";
mood = "angry";
mood = "meh";
//mood = "ok"; // Error: Type '"ok"' is not assignable to type '"happy" | "sad" | "angry" | "meh"'

type DayOfWeek = "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday";

let today: DayOfWeek = "Monday";
// today = "Holiday"; // Error: Type '"Holiday"' is not assignable to type 'DayOfWeek'
// Because "Holiday" is not a valid value for DayOfWeek (Monday-Tuesday-Wednesday-Thursday-Friday-Saturday-Sunday)

########################################################################################################


########################################################################################################
* SECTION 8 : Tuples And Enums *
---------------------------------------
* Tuples
---------------------------------------
-> Tuples are a special type exclusive to TypeScript 
-> Tuples are arrays of fixed lengths and ordered with specific types like super rigid arrays

> let myTuple: [number, string];

myTuple = [10, "Typescript is fun"]; (ok)
myTuple = ["Typescript is fun", 10]; (not ok)

//const color: number[] = [255, 0, 0];
//const color: [number, number, number] = [255, 0]; // Error: Type 'string' is not assignable to type 'number'.
//const color: [number, number, number] = [255, 0, 0, 0, 2]; // Error: Type 'number' is not assignable to type 'undefined'. 
//const color: [number, number, number] = [255, 0, 0, 2]; // Source has 4 elements, target expects 3.

const color: [number, number, number] = [255, 0, 0];

type HTTPResponse = [number, string];

const goodRes: HTTPResponse = [200, 'OK'];
//goodRes[0] = "200"; // Error: Type 'string' is not assignable to type 'number'.

/* goodRes.push(123); // No error
goodRes.pop(); // No error
goodRes.pop();   
goodRes.pop();
*/ 
console.log(goodRes);

// Why not to use objects for tuples

type HTTPResponseType = {
    code: number,
    message: string
}

const goodResObj: HTTPResponseType = { code: 200, message: 'OK' };


---------------------------------------
* Enums
---------------------------------------
-> Enums allow us to define a "set of named constants"
-> We can give these constants numeric or string values
-> There's quite a few options when it comes to enums

> enum Responses {
    no, // 0
    yes, // 1
    maybe // 2
}

> enum Responses {
    no = 2, // 2
    yes, // 3
    maybe // 4
}

> enum Responses {
    no = 2, // 2
    yes = 10, // 10
    maybe = 24 // 24
}

> enum Responses {
    no = 'No',
    yes = 'Yes',
    maybe = 'Maybe'
}

> enum Responses {
    no = 0,
    yes = 1,
    maybe = 'Maybe'
}


enum OrderStatus {
    PENDING,
    SHIPPED,
    DELIVERED,
    RETURNED
}


const myStatus = OrderStatus.DELIVERED;


function isDelivered(status: OrderStatus): boolean {
    return status === OrderStatus.DELIVERED
}

isDelivered(myStatus); // true

enum ArrowKeys {
    UP = "up",
    DOWN = "down",
    LEFT = "left",
    RIGHT = "right",
    ERROR = 235
}

ArrowKeys.LEFT; // "left"
ArrowKeys.RIGHT; // "right"
ArrowKeys.ERROR; // 235

########################################################################################################


########################################################################################################
* SECTION 9 : Interfaces *
---------------------------------------
* Interfaces
---------------------------------------
-> Interfaces serve almost the exact some purpose as type aliases (with slightly different syntax)
-> We can use them to create reusable, modular types that describe the "shapes of objects"

> interface Person {
    name: string;
    age: number;
}

const sayHappyBirthday = (person: Person) => {
    return `Hey ${person.name}, congrats on turning ${person.age}`
}

sayHappyBirthday({name: "Vedat", age: 23})

interface Point {
    x: number,
    y: number
}

const pt: Point = { x: 123, y: 1234 };

---------------------------------------
* Readonly and Optional Interface Properties
---------------------------------------
interface Person {
    readonly id: number,
    first: string,
    last: string,
    nickname?: string
}

const thomas: Person = { id: 123123, first: 'Thomas', last: 'Jefferson', nickname: "Tom" };
const john: Person = { id: 123123123, first: 'John', last: 'Adams', nickname: 'The Atlas of Independence' };

thomas.first = "Tommy";
//thomas.id = 123; // Error: Cannot assign to 'id' because it is a read-only property.

---------------------------------------
* Interface Methods
---------------------------------------
interface Person {
    readonly id: number;
    first: string;
    last: string;
    nickname?: string;
    //sayHi: () => string;
    sayHi(): string;
}

const thomas: Person = {
    id: 123123, 
    first: 'Thomas', 
    last: 'Jefferson', 
    nickname: "Tom",
    sayHi: () => {
        return `Hello, my name is ${this.first} ${this.last}`;
    }
};


---------------------------------------
* Interface Methods Parameters
---------------------------------------
interface Product {
    name: string,
    price: number,
    applyDiscount(discount: number): number;
}


const shoes: Product = {
    name: 'Nike Air Max',
    price: 100,
    applyDiscount(amount: number): number {
        const newPrice = this.price * (1-amount);
        this.price = newPrice;
        return this.price;
    }
};

console.log(shoes.applyDiscount(0.4));

---------------------------------------
* Reopening Interfaces
---------------------------------------
interface Dog {
    name: string;
    age: number;
}

interface Dog {
    breed: string;
    bark(): string;
}

const fido: Dog = {
    name: 'Fido',
    age: 3,
    breed: 'Golden Retriever',
    //bark: () => 'Woof'
    bark() {
        return "Woof Woof!"
    }
};


---------------------------------------
* Extending Interfaces
---------------------------------------
interface ServiceDog extends Dog {
    isTrained: boolean;
    performTask(): string;
}

const buddy: ServiceDog = {
    name: 'Buddy',
    age: 5,
    breed: 'Labrador',
    isTrained: true,
    bark() {
        return "Woof Woof!";
    },
    performTask() {
        return "I'm helping my human!";
    }
};


console.log(buddy);
console.log(buddy.performTask());
console.log(buddy.bark());


interface ServiceDog extends Dog {
    job: "drug sniffer" | "bomb" | "guide dog";
}

const chewy: ServiceDog = {
    name: 'Chewy',
    age: 4.5,
    breed: 'German Shepherd',
    job: 'bomb',
    bark() {
        return "Woof Woof!";
    }
}

---------------------------------------
* Interface Multiple Inheritance
---------------------------------------
interface Person {
    name: string;
}

interface Employee {
    readonly id: number;
    email: string;
}

interface Engineer extends Person, Employee {
    level: string
    languages: string[];
}

const pierre: Engineer = {
    name: 'Pierre',
    id: 123,
    email: 'pierre@gmail.com',
    level: 'Senior',
    languages: ['JavaScript', 'TypeScript', 'Python']
}

########################################################################################################