*** TypeScript Notes ***

########################################################################################################
* SECTION 1 : Introduction *
---------------------------------------
* Topics
---------------------------------------
-> Installation
-> Type Basics
-> Functions
-> Object Types
-> Array Types 
-> Union Types 
-> Tuples/Enums
-> Interfaces
-> TS Compiler
-> DOM Mini Project
-> JS Classes
-> TS Classes 
-> Generics
-> Narrowing
-> Declarations
-> Modules
-> Webpack + TS
-> React + TS

---------------------------------------
* What is TypeScript ?
---------------------------------------
-> Typescript is a programming language developed by Microsoft that extends JavaScript by adding
static types
-> It is designed for large-scale Javascript application development, offering benefits such as improved
maintainability, easier refactoring, and better tooling support through type-checking
-> Key Features: Static Typing | ES6+ Features | Type Inference | Interface and Type Declarations 
-> Advantages of TypeScript : 
--> Type Safety
--> Improved Code Quality
--> Better Tooling
--> Ecosystem Compatibility
--> Scalability
-> Overall, Typescript aims to make JavaScript development more robust and scalable by introducing static typing
and other features without sacrificing compatibility with JS's ecosystem

-> JavaScript is quirky...
-> Typescript is Javascript with types

---------------------------------------
* TypeScript Overview
---------------------------------------
-> Static Checking : Typescript detects erros in our code "without running it"
-> This is called static checking
-> TypeScript does this error checknig on the basis of "kinds of data" in our program
AKA types
-> TypeScript's Type System
--> Helpos us find erros
--> Analyzes our code as we type
--> Only exists in development
-> First use ts then compile js
-> Typescript gives the errors before "runtime"
########################################################################################################


########################################################################################################
* SECTION 2 : Installation & Setup *
---------------------------------------
* Installing Typescript
---------------------------------------
-> First install node
-> Then run "npm install -g typescript" for installing typescript globally

---------------------------------------
* The TypeScript Playground
---------------------------------------
-> You can use for trying codes online : https://www.typescriptlang.org/play/

---------------------------------------
* How We Use Typescript
---------------------------------------
-> Create ".ts" file
-> Make some work
-> Compile that ts code into js with "tsc" command
> tsc <filename>.tsc
-> Then run that .js file with node command
> node <filename>.js
########################################################################################################


########################################################################################################
* SECTION 3 : Type Annotation Basics *
---------------------------------------
* Our First Type Annotation
---------------------------------------
-> Primitive Types 
--> Number | String | Booelan | Null | Undefined | Void | Any | Never | Unknown
-> Object Types
--> Object | Array | Function | Tuple | Enum | Others

-> Where we use that types in our projects
--> "This variable is a string"
--> "This function returns a boolean"
--> "This function accepts two numbers and returns a number"
--> "This object must have a property called "colors", set to an array of strings"

-> Variable Types: Assigning a basic type to a variable is easy - just add ":Type" after
the variable name! (Also called 'Type Annotation')

// Declaring a variable in JS
> const myAwesomeVariable = 'So Awesome!';
// Declaring a variable in TS
> const myAwesomeVariable: string = 'So Awesome!';

-> let myVar: type = value


-> Strings: Strings represent character values like "I love Typescript"
-> We can tell TypeScript that something is a string using the type annotation fo "string" (all lowercase)

> let myString: string = "Words!!!";

(x) myString = 100; // CAN'T reassign to a different type

(ok) myString = "New Words!!!!";


---------------------------------------
* Working With Numbers & Booleans
---------------------------------------
-> Some programming langauges have many number types  - float, int etc.
-> In TypeScript numbers are just numbers
-> Numbers can be typed with a simple Type Annotation of "number" (all lowercase)

> let myNumber: number = 42;
> myNumber = "I'm a string!"; (x)
> myNumber = 60; // CAN reassign to a value of same type

-> Boolean variables represent simple "true" or "false" values
-> Booleans can be typed with a simple type annotation of "boolean"

> const myBoolean: boolean = true;
> myBoolean = 87; (x)
> myBoolean = false; (ok)


---------------------------------------
* Compiling TypeScript
---------------------------------------
-> Go the folder that you want to run "tsc" command in it
-> Then run "tsc <filename>.tsc"
-> Then run "node <filename>.js"

-> At the end of day, we are getting plain js file because browser can only understand plain 
javascript code


---------------------------------------
* Type Inference
---------------------------------------
-> Type Inference refers to the Typescript compiler's ability to infer types from certain
values in your code
-> Typescript can remember a value's type even if you didn't provide a type annotation, and
it will enforce that type moving forword

> let x = 27;
> x = 'twenty-seven';
// ERROR - Type 'string' is not assignable to type 'number'

---------------------------------------
* Any Type
---------------------------------------
-> 'any' is an escape hatch!
-> It turns off type checking for this variable so you can do your thing
-> NOTE: it sort of defats the purpose of TS and types, so use it sparingly!

> const myComplicatedData: any = "I'm going to be complicated!";

> myComplicatedData = 87; // OK
> myComplicatedData = "abc..."; // OK
> myComplicatedData = true; // OK
########################################################################################################


########################################################################################################
* SECTION 4 : Functions *
---------------------------------------
* Function Parameter Types
---------------------------------------
-> In TypeScript, we can specify the type fo function parameters in a function definition
-> This allows Typescript to enforce the types for the values being passed into your Function
-> Typing parameters is just like typing variables

> const encourageStudent = (name: string) => {
    return `Hey, ${name}, you're doing GREAT!`;
}

encourageStudent('you'); (ok)

encourageStudent(85); (x) 

> const doSomething = (person: string, age: number, isFunny: boolean) => {
    return `Hi there, ${person}! You are ${age} years old. Are you funny? ${isFunny}`;
}

//console.log(doSomething("VedatCinbat")) // Error: Expected 3 arguments, but got 1.
//console.log(doSomething("VedatCinbat", 24)); // Error: Expected 3 arguments, but got 2.
//console.log(doSomething("VedatCinbat", 24, true)); // Hi there, VedatCinbat! You are 24 years old. Are you funny? true


---------------------------------------
* Working With Default Parameters
---------------------------------------
-> Add "default value" after type annotations

> function greet(person: string = "stranger") {
    return `Hi there, ${person}!`;
}

---------------------------------------
* Return Type Annotation
---------------------------------------
-> We can specify the type returned by a function
-> Even through TypeScript can often infer this, I prefer the explicit annotations
-> Add the type annotation after the functions parameter list

> const addNums = (x: number, y:number): number => {
    return x + y;
}

addNums(5,5);
// --> 10

function rando(num: number): number | string {
    if(Math.random() < 0.5) {
        return num.toString();
    }

    return num;
}


---------------------------------------
* Anonymous Function Contextual Typing
---------------------------------------
-> Anonymous Function: When TypeScript can infer how an unnamed function is going to be called,
it can automatically infer its parameter's types

> const numbers = [1, 2, 3];

> numbers.forEach(num => {
    return num.toUpperCase(); // Error
    // .toUpperCase() doesn't work for nums!
})

> const colors = ['red', 'green', 'blue'];

// TS can automatically infer the type of the return value from
> colors.map(color => {
    return color.toUpperCase()
})


---------------------------------------
* The Void Type
---------------------------------------
-> Void is a return type for functions that don't return anything
-> It means just that - this function is void of any data
-> Typescript can infer this type fairly well, but sometimes it may want you to 
annotate a function with a void return explicity

> const annoyUser = (num: number): void => {
    for(let i = 0; i < num; i++) {
        alert("HIIIII!!");
    }
}

> function printTwice(msg: string): void {
    console.log(msg);
    console.log(msg);

    // return ""; // Error: Type '""' is not assignable to type 'void'.
}

> printTwice("Hello, World!");


---------------------------------------
* Never Type
---------------------------------------
-> The never type represents values that NEVER occur
-> We might use it to annotate a function that always throws an exception, or a function
that never finishes executing
-> Don't confuse with void - void returns undefined or null, which is technically still a 
type of value
-> With "never", a function doesn't even finish executing 

> const neverStop = (): never => {
    while(true) {
        console.log("I'm still going!!!")
    }
}

> const giveError = (msg: string) => {
    throw new Error(msg)
}
########################################################################################################

########################################################################################################
* SECTION 5 : Object Types *
---------------------------------------
* Objects
---------------------------------------
-> Objects can be typed bu declaring what the object should look like in the annotation
-> Accessing a property that isn't defined or performing operations without keeping types in mid
will throw errors!

> const printName = (name: {first: string, last: string}) => {
    return `Name: ${first} ${last}`;
}

printName({first: 'Vedat', last: 'Cinbat'});

function printName(person: {first: string, last: string}) {
    console.log(`${person.first} ${person.last}`)
}

//printName({first: "John"}); // Error: Argument of type '{ first: string; }' is not assignable to parameter of type '{ first: string; last: string; }'.
printName({first: "John", last: "Doe"});


//let coordinate: {x: number, y: number} = {x: 10, y: 20, z: 30}; // Error: Object literal may only specify known properties, and 'z' does not exist in type '{ x: number; y: number; }'.
let coordinate: {x: number, y: number} = {x: 10, y: 20}; // OK

// {x: number, y: number} is a return type
function randomCoordinate(): {x: number, y: number} {
    return {x: Math.random(), y: Math.random()};
}

---------------------------------------
* Excess Properties
---------------------------------------
//printName({first: "Mick", last: "Jagger", age: 47}) // Error: Object literal may only specify known properties, and 'age' does not exist in type '{ first: string; last: string; }'.

const singer = {first: "Mick", last: "Jagger", age: 47, isAlive: true}

printName(singer) // OK


---------------------------------------
* Type Alias
---------------------------------------
-> Instead of writing out object types in an annotation, we can declare them separaretly in a "type alias",
which is simply the desired shape of the object
-> This allows us to make our code more readable and even reuse the types elsewhere in our code 

type Person = {
    name: string;
    age: number;
}

const sayHappyBirthday = (person: Person) => {
    return `Hey ${person.name}, congrats on turning ${person.age}`;
}

sayHappyBirthday({name: "Jerry", age: 42});
--------------------------------------------------------------------------------
type Point = {
    x: number;
    y: number;
}

let coordinate: Point = { x: 10, y: 20 };

function randomCoordinate() {
    return { x: Math.random(), y: Math.random() };
}

function doublePoint(point: Point): Point {
    return {x: point.x * 2, y: point.y * 2};
}

randomCoordinate();
doublePoint(coordinate); // OK


---------------------------------------
* Nested Objects
---------------------------------------
> const describePerson = (person: {
    name: string;
    age: number;
    parentNames: {
        mom: string;
        dad: string;
    }
}) => {
    return `Person: ${name},
    Age: ${age},
    parents: ${parentNames.mom} ${parentNames.dad}`;
}

describePerson({name: 'Jimmy', age: 10, parents: {mom: 'Kim', dad: 'Steve'}})

type Song = { 
    title: string, 
    artist: string, 
    numStreams: number, 
    credits: { 
        producer: string, 
        writer: string 
    } 
}

function calculatePayout(song: Song): number {
    return song.numStreams * 0.0033;
}

function printSong(song: Song): void {
    console.log(`Title: ${song.title} - Artist: ${song.artist}`);
}

const mySong: Song = {
    title: "Unchained Melody",
    artist: "The Righteous Brothers",
    numStreams: 1236573,
    credits: {
        producer: "Phil Spector",
        writer: "Alex North"
    }
}

const earnings = calculatePayout(mySong); // OK
console.log(earnings);
printSong(mySong); // OK

---------------------------------------
* Optional Properties
---------------------------------------
type Point = {
    x: number,
    y: number,
    z?: number // Optional property
}

const point1: Point = { x: 1, y: 2 }; // OK
const point2: Point = { x: 1, y: 2, z: 3 }; // OK
const point3: Point = { x: 1 }; // Error: Property 'y' is missing

---------------------------------------
* The Readonly Modifier
---------------------------------------
type User = {
    readonly id: number,
    username: string,
    readonly hobbies: string[]
}

const user: User = {
    id: 1,
    username: "johndoe",
    hobbies: ["reading", "swimming"]
}

//user.id = 2; // Error: Cannot assign to 'id' because it is a read-only property
user.username = "janedoe"; // OK
user.hobbies.push("running"); // OK

---------------------------------------
* Intersection Types
---------------------------------------
type Circle = {
    radius: number;
}

type Colorful = {
    color: string;
}

type ColorfulCircle = Circle & Colorful;    

const happyFace: ColorfulCircle = {
    radius: 42,
    color: "yellow"
}

const sadFace: ColorfulCircle = {
    radius: 50,
    color: "blue"
}
########################################################################################################

########################################################################################################
* SECTION 6 : Array Types *
---------------------------------------
* Array Types
---------------------------------------
-> Arrays can be typed using a type annotation followed by empty array brackets, like
number[] for an array of numbers
-> Note: These arrays only allow daya fo that one type inside them.

-> Using brackets
> let names: string[] = ["hello", "world"];
> let ages: number[] = [13, 31, 42, 56];

-> Alternate syntax
> let names: Array<string> = ["hello", "world"];
> let ages: Array<number> = [13, 31, 42, 56];


const activeUsers: string[] = ['John', 'Doe', 'Jane'];
const activeNumbers: number[] = [1, 2, 3];


activeUsers.push('Smith');
//activeUsers.push(4); // Error: Argument of type '4' is not assignable to parameter of type 'string'. 


const ageList: number[] = [25, 30, 35, 40];

ageList[0] = 99;
// ageList[0] = "99"; // Error: Type 'string' is not assignable to type 'number'.


---------------------------------------
* More Array Syntax
---------------------------------------
-> We can create our custom type and we can use that custom type for declaring variable 
that array of that custom type :

type Point = {
    x: number;
    y: number;
}

const coords: Point[] = []
coords.push({ x: 10, y: 20 });
//coords.push({x: 8}) // Error: Property 'y' is missing in type '{ x: number; }' but required in type 'Point'.


---------------------------------------
* Multidimensional Arrays
---------------------------------------














########################################################################################################